{"meta":{"title":"Hello，I'm sen","subtitle":null,"description":null,"author":"sen","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"20190818","slug":"20190818","date":"2019-08-18T02:04:26.000Z","updated":"2019-08-20T07:05:36.349Z","comments":true,"path":"2019/08/18/20190818/","link":"","permalink":"http://yoursite.com/2019/08/18/20190818/","excerpt":"二叉树非递归方法： /*感谢博主，提供的思路 https://blog.csdn.net/z_ryan/article/details/80854233 */ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stack&gt;using namespace ::std;/*感谢博主，提供的思路 https://blog.csdn.net/z_ryan/article/details/80854233 *///Binary Tree Nodetypedef struct node&#123; int data; struct node* lchild; //左孩子 struct node* rchild; //右孩子 node(int x) :data(x), lchild(NULL), rchild(NULL) &#123;&#125;;&#125;BTNode; //中序遍历//思路：所有的root 看作是左节点void InOrderWithoutRecursion1(BTNode* root)&#123; //空树 if (root == NULL) return; //树非空 BTNode* p = root; stack&lt;BTNode*&gt; s; while (!s.empty() || p) &#123; //一直遍历到左子树最下边，边遍历边保存根节点到栈中 while (p) &#123; s.push(p); p = p-&gt;lchild; &#125; //当p为空时，说明已经到达左子树最下边，这时需要出栈了 if (!s.empty()) &#123; p = s.top(); s.pop(); cout &lt;&lt; p-&gt;data; //进入右子树，开始新的一轮左子树遍历(这是递归的自我实现) p = p-&gt;rchild; &#125; &#125;&#125;","text":"二叉树非递归方法： /*感谢博主，提供的思路 https://blog.csdn.net/z_ryan/article/details/80854233 */ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stack&gt;using namespace ::std;/*感谢博主，提供的思路 https://blog.csdn.net/z_ryan/article/details/80854233 *///Binary Tree Nodetypedef struct node&#123; int data; struct node* lchild; //左孩子 struct node* rchild; //右孩子 node(int x) :data(x), lchild(NULL), rchild(NULL) &#123;&#125;;&#125;BTNode; //中序遍历//思路：所有的root 看作是左节点void InOrderWithoutRecursion1(BTNode* root)&#123; //空树 if (root == NULL) return; //树非空 BTNode* p = root; stack&lt;BTNode*&gt; s; while (!s.empty() || p) &#123; //一直遍历到左子树最下边，边遍历边保存根节点到栈中 while (p) &#123; s.push(p); p = p-&gt;lchild; &#125; //当p为空时，说明已经到达左子树最下边，这时需要出栈了 if (!s.empty()) &#123; p = s.top(); s.pop(); cout &lt;&lt; p-&gt;data; //进入右子树，开始新的一轮左子树遍历(这是递归的自我实现) p = p-&gt;rchild; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//所有的节点都可看做是根节点void PreOrderWithoutRecursion1(BTNode* root)&#123; if (root == NULL) return; BTNode* p = root; stack&lt;BTNode*&gt; s; while (!s.empty() || p) &#123; //边遍历边打印，并存入栈中， while (p) &#123; cout &lt;&lt; p-&gt;data;//root s.push(p); p = p-&gt;lchild; &#125; //当p为空时，说明根和左子树都遍历完了，该进入右子树了 if (!s.empty()) &#123; p = s.top(); s.pop(); p = p-&gt;rchild; &#125; &#125;&#125;//后序遍历//后序遍历的难点在于：需要判断上次访问的节点是位于左子树，还是右子树。//若是位于左子树，则需跳过根节点，//先进入右子树，再回头访问根节点；//若是位于右子树，则直接访问根节点。void PostOrderWithoutRecursion(BTNode* root)&#123; if (root == NULL) return; stack&lt;BTNode*&gt; s; //pCur:当前访问节点，pLastVisit:上次访问节点 BTNode* pCur, *pLastVisit; pCur = root; pLastVisit = NULL; //先把pCur移动到左子树最下边 while (pCur) &#123; s.push(pCur); pCur = pCur-&gt;lchild; &#125; while (!s.empty()) &#123; //走到这里，pCur都是空，并已经遍历到左子树底端(看成扩充二叉树，则空，亦是某棵树的左孩子) pCur = s.top(); s.pop(); //一个根节点被访问的前提是：无右子树或右子树已被访问过 if (pCur-&gt;rchild == NULL || pCur-&gt;rchild == pLastVisit) &#123; cout&lt;&lt; pCur-&gt;data; //修改最近被访问的节点 pLastVisit = pCur; &#125; /*这里的else语句可换成带条件的else if: else if (pCur-&gt;lchild == pLastVisit) //若左子树刚被访问过，则需先进入右子树(根节点需再次入栈) 因为：上面的条件没通过就一定是下面的条件满足。仔细想想！ */ else &#123; //根节点再次入栈 s.push(pCur); //进入右子树，且可肯定右子树一定不为空 pCur = pCur-&gt;rchild; while (pCur) &#123; s.push(pCur); pCur = pCur-&gt;lchild; &#125; &#125; &#125;&#125;int main()&#123; BTNode * root = new BTNode(5); root-&gt;rchild= new BTNode(7); root-&gt;lchild = new BTNode(3); root-&gt;lchild-&gt;lchild = new BTNode(2); root-&gt;lchild-&gt;rchild = new BTNode(4); root-&gt;rchild-&gt;lchild = new BTNode(6); root-&gt;rchild-&gt;rchild = new BTNode(8); InOrderWithoutRecursion1(root); cout &lt;&lt; endl; PreOrderWithoutRecursion1(root); cout &lt;&lt; endl; PostOrderWithoutRecursion(root); return 0;&#125;","categories":[],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/二叉树/"},{"name":"非递归","slug":"非递归","permalink":"http://yoursite.com/tags/非递归/"}]},{"title":"20180817","slug":"20190817-md","date":"2019-08-17T14:35:49.000Z","updated":"2019-08-20T06:53:11.492Z","comments":true,"path":"2019/08/17/20190817-md/","link":"","permalink":"http://yoursite.com/2019/08/17/20190817-md/","excerpt":"中序遍历和层次遍历 输入中序遍历和层次遍历 12345678910111213141516171819202122232425262728293031323334TreeNode* createTree(vector&lt;int&gt;inorder, vector&lt;int&gt;seq, int begin, int end)&#123; if (seq.size() &lt;= 0) return nullptr; TreeNode *root = new TreeNode(seq[0]); vector&lt;int&gt;left; vector&lt;int&gt;right; int k; for (k = begin; k &lt;= end; ++k) if (inorder[k] == seq[0]) break; bool isleft; for (int i = 1; i &lt; seq.size(); ++i)//层次遍历 &#123; isleft = false; for (int j = begin; j &lt; k; ++j) &#123; if (seq[i] == inorder[j]) &#123; isleft = true; break; &#125; &#125; if (isleft) left.push_back(seq[i]); else right.push_back(seq[i]); &#125; root-&gt;left = createTree(inorder, left, begin, k - 1);// root-&gt;right = createTree(inorder, right, k + 1, end); return root;&#125;","text":"中序遍历和层次遍历 输入中序遍历和层次遍历 12345678910111213141516171819202122232425262728293031323334TreeNode* createTree(vector&lt;int&gt;inorder, vector&lt;int&gt;seq, int begin, int end)&#123; if (seq.size() &lt;= 0) return nullptr; TreeNode *root = new TreeNode(seq[0]); vector&lt;int&gt;left; vector&lt;int&gt;right; int k; for (k = begin; k &lt;= end; ++k) if (inorder[k] == seq[0]) break; bool isleft; for (int i = 1; i &lt; seq.size(); ++i)//层次遍历 &#123; isleft = false; for (int j = begin; j &lt; k; ++j) &#123; if (seq[i] == inorder[j]) &#123; isleft = true; break; &#125; &#125; if (isleft) left.push_back(seq[i]); else right.push_back(seq[i]); &#125; root-&gt;left = createTree(inorder, left, begin, k - 1);// root-&gt;right = createTree(inorder, right, k + 1, end); return root;&#125; 和中序遍历个和前序遍历相区别： 12345678910111213141516171819202122232425262728293031323334353637TreeNode* build_tree(vector&lt;int&gt; &amp;pre, vector&lt;int&gt; &amp;vin,int start_pre ,int end_pre, int start_in, int end_in )&#123; //int root_value = pre[0];//new root TreeNode* root = new TreeNode(pre[start_pre]); if (start_pre == end_pre ) &#123; if (start_in == end_in &amp;&amp; pre[start_pre] == vin[start_in]) return root; &#125; //中序遍历找到root int root_inorder = pre[start_pre]; int index_in = start_in; while (index_in &lt;= end_in) &#123; if (vin[index_in] == root_inorder) break; index_in++; &#125; int length = index_in - start_in; int left_pre_end = start_pre + length; //构建左子树 if (length&gt;0) &#123; root-&gt;left = build_tree(pre, vin, start_pre + 1, left_pre_end, start_in, index_in - 1); &#125; //构建右子树 if (length &lt; end_pre - start_pre) &#123; root-&gt;right = build_tree(pre, vin, left_pre_end+1, end_pre, index_in+1, end_in); &#125; return root;&#125;","categories":[],"tags":[]},{"title":"midNumber","slug":"midNumber","date":"2019-08-08T12:52:33.000Z","updated":"2019-08-20T06:54:45.406Z","comments":true,"path":"2019/08/08/midNumber/","link":"","permalink":"http://yoursite.com/2019/08/08/midNumber/","excerpt":"题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。","text":"题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: //建大小堆 priority_queue&lt;int&gt; large; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; small; void adjust() &#123; if (large.size() &gt; small.size() + 1)//size的增加大于+1 &#123; int tmp = large.top(); large.pop(); small.push(tmp); &#125; if (small.size() &gt; large.size() + 1)// &#123; int tmp = small.top(); small.pop(); large.push(tmp); &#125; &#125; void Insert(int num) &#123; if (!large.empty()) &#123; if (large.top() &lt; num) small.push(num); else large.push(num); adjust(); &#125; else large.push(num); &#125; double GetMedian() &#123; int num = large.size() + small.size(); if (num % 2 == 0) return double(large.top() + small.top()) / 2; else &#123; if (large.size() &gt; small.size()) return double(large.top()); else return double(small.top()); &#125; &#125;&#125;;","categories":[],"tags":[]},{"title":"二叉搜索树的第k个结点","slug":"20190808","date":"2019-08-08T12:12:37.000Z","updated":"2019-08-20T06:52:52.575Z","comments":true,"path":"2019/08/08/20190808/","link":"","permalink":"http://yoursite.com/2019/08/08/20190808/","excerpt":"题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 思路：将节点中序遍历保存在容器里面， 注意：对不合法输入情况的考虑全面","text":"题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 思路：将节点中序遍历保存在容器里面， 注意：对不合法输入情况的考虑全面 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* KthNode(TreeNode* pRoot, int k) &#123; //stack,zhongxu bianli //stack&lt;TreeNode*&gt; inorder_queue; if (pRoot == NULL) return NULL; vector&lt;TreeNode*&gt; inorder_queue; //inorder_queue.pu Inorder_Traverse(pRoot, inorder_queue); //while (k--) //&#123; // inorder_queue.pop(); //&#125; if (k &gt; inorder_queue.size() || k &lt; 1)//dui return NULL; return inorder_queue[k-1]; &#125; void Inorder_Traverse(TreeNode* pRoot, vector&lt;TreeNode*&gt; &amp;inorder_queue) &#123; if (pRoot == NULL ) &#123; return; &#125; //preorder Inorder_Traverse(pRoot-&gt;left, inorder_queue); inorder_queue.push_back(pRoot);//inorder Inorder_Traverse(pRoot-&gt;right, inorder_queue); //postorder &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"20190728","date":"2019-07-28T13:54:11.168Z","updated":"2019-08-20T06:52:09.062Z","comments":true,"path":"2019/07/28/20190728/","link":"","permalink":"http://yoursite.com/2019/07/28/20190728/","excerpt":"数据结构：二叉树测试了一下图片assets/time.jpg 先来一题比较难的： 二叉搜索树与双向链表： 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 分析： 要注意二叉树里面是有数据联系的，只允许修改node的指针：","text":"数据结构：二叉树测试了一下图片assets/time.jpg 先来一题比较难的： 二叉搜索树与双向链表： 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 分析： 要注意二叉树里面是有数据联系的，只允许修改node的指针： 123456789101112131415//向左遍历TreeNode* left = Convert(pRootOfTree-&gt;left);TreeNode* run_node = left;//保存最左边的节点while (run_node &amp;&amp; run_node-&gt;right)&#123; run_node = run_node-&gt;right;&#125;if (left)&#123; run_node-&gt;right = pRootOfTree; pRootOfTree-&gt;left = run_node;&#125; 再看右子树的处理 123456 TreeNode* right = Convert(pRootOfTree-&gt;right);if (right)&#123; right-&gt;left = pRootOfTree; pRootOfTree-&gt;right = right;&#125; 再看最后的返回处理：返回头节点 12345//向左遍历TreeNode* left = Convert(pRootOfTree-&gt;left); .....return left != NULL ? left : pRootOfTree;","categories":[],"tags":[]},{"title":"first blog","slug":"first-blog","date":"2019-07-27T11:16:29.000Z","updated":"2019-08-20T06:54:11.138Z","comments":true,"path":"2019/07/27/first-blog/","link":"","permalink":"http://yoursite.com/2019/07/27/first-blog/","excerpt":"201903111.c语言的复习：|的用法。或运算 123/**Initializes the CPU, AHB and APB busses clocks*/RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;","text":"201903111.c语言的复习：|的用法。或运算 123/**Initializes the CPU, AHB and APB busses clocks*/RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE; FREERTOS的时钟源函数： 123456789/** * @brief Configures the SysTick clock source. * @param CLKSource: specifies the SysTick clock source. * This parameter can be one of the following values: * @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source. * @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source. * @retval None */void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource) config the clock source","categories":[],"tags":[]},{"title":"BTree","slug":"hello-world","date":"2019-07-27T11:08:40.147Z","updated":"2019-08-20T06:54:28.675Z","comments":true,"path":"2019/07/27/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/27/hello-world/","excerpt":"刷题二叉树的镜像 操作给定的二叉树，将其变换为源二叉树的镜像。 二叉树的镜像定义： 123456789101112二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 思路：左右子树均互换，子树的子树也互换故可以写为： 1234567//对于每个node void Change_child_pointer(TreeNode *pRoot) &#123; TreeNode *temp_child = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = temp_child; &#125; 此时可以用递归来解决此类问题","text":"刷题二叉树的镜像 操作给定的二叉树，将其变换为源二叉树的镜像。 二叉树的镜像定义： 123456789101112二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 思路：左右子树均互换，子树的子树也互换故可以写为： 1234567//对于每个node void Change_child_pointer(TreeNode *pRoot) &#123; TreeNode *temp_child = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = temp_child; &#125; 此时可以用递归来解决此类问题 1234567void Mirror(TreeNode *pRoot) &#123; if (pRoot != NULL) &#123; Change_child_pointer(pRoot); Mirror(pRoot-&gt;left); Mirror(pRoot-&gt;right); &#125;","categories":[],"tags":[]}]}